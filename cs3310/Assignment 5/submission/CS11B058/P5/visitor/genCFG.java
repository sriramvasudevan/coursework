//
// Generated by JTB 1.3.2
//

package visitor;

import syntaxtree.*;
import java.util.*;

import base.CFNode;
import base.SymbolTable;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class genCFG<R> implements GJNoArguVisitor<R> {

    CFNode                  prevnode, currnode, rootnode;
    HashMap<CFNode, String> jumpnodes   = new HashMap<CFNode, String>();
    HashMap<String, CFNode> labelnodes  = new HashMap<String, CFNode>();
    boolean                 jumplabel   = true;
    ArrayList<CFNode>       rootlist    = new ArrayList<CFNode>();
    public SymbolTable      symtab      = new SymbolTable();
    int                     label_count = 0;
    String                  label       = null;
    String                  currfunc    = null;
    Integer                 count       = 0;

    // Function to add missing edges in the CFG
    void addJumpEdges() {
        Iterator<Map.Entry<CFNode, String>> it = jumpnodes.entrySet()
                .iterator();
        while (it.hasNext()) {
            Map.Entry<CFNode, String> i = it.next();
            i.getKey().successors.add(labelnodes.get(i.getValue()));
        }
    }

    // Add new node to CFG
    void addNode() {
        if (prevnode != null) {
            prevnode.successors.add(currnode);
        }
        else {
            if (rootnode == null) {
                rootnode = currnode;
            }
        }
        prevnode = currnode;
    }

    // Prints the Control Flow Graph generated
    void printCFG() {
        ArrayList<CFNode> dp = new ArrayList<CFNode>();
        ArrayList<CFNode> visited = new ArrayList<CFNode>();
        for (CFNode root : rootlist) {
            System.out.println("fn:");
            dp.add(root);
            while (!dp.isEmpty()) {
                CFNode temp = dp.remove(0);
                if (!visited.contains(temp)) {
                    visited.add(temp);
                    System.out.println(temp.no);
                    System.out.println(temp.in);
                    System.out.println(temp.out);
                    System.out.println(temp.use);
                    System.out.println(temp.def);
                    System.out.println();
                    for (CFNode node : temp.successors) {
                        dp.add(node);
                    }
                }
            }
            System.out.println();
        }
    }

    //
    // Auto class visitors--probably don't need to be overridden.
    //
    public R visit(NodeList n) {
        R _ret = null;
        int _count = 0;
        for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
            e.nextElement().accept(this);
            _count++;
        }
        return _ret;
    }

    public R visit(NodeListOptional n) {
        if (n.present()) {
            R _ret = null;
            jumplabel = true;
            int _count = 0;
            for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
                e.nextElement().accept(this);
                _count++;
            }
            return _ret;
        }
        else
            return null;
    }

    public R visit(NodeOptional n) {
        if (n.present())
            return n.node.accept(this);
        else
            return null;
    }

    public R visit(NodeSequence n) {
        R _ret = null;
        int _count = 0;
        for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
            e.nextElement().accept(this);
            _count++;
        }
        return _ret;
    }

    public R visit(NodeToken n) {
        return null;
    }

    //
    // User-generated visitor methods below
    //

    /**
     * f0 -> "MAIN" f1 -> StmtList() f2 -> "END" f3 -> ( Procedure() )* f4 ->
     * <EOF>
     */
    public R visit(Goal n) {
        R _ret = null;
        prevnode = null;
        rootnode = null;
        currfunc = "main";
        symtab.arg3.put(currfunc, 0);

        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        rootlist.add(rootnode);

        n.f3.accept(this);
        n.f4.accept(this);

        addJumpEdges();
        symtab.allocRegs(rootlist);
        // printCFG(); // for debugging

        return _ret;
    }

    /**
     * f0 -> ( ( Label() )? Stmt() )*
     */
    public R visit(StmtList n) {
        R _ret = null;
        n.f0.accept(this);
        return _ret;
    }

    /**
     * f0 -> Label() f1 -> "[" f2 -> IntegerLiteral() f3 -> "]" f4 -> StmtExp()
     */
    public R visit(Procedure n) {
        R _ret = null;
        jumplabel = false;
        prevnode = null;
        rootnode = null;
        currfunc = n.f0.f0.toString();
        symtab.arg3.put(currfunc, 0);

        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
        rootlist.add(rootnode);

        return _ret;
    }

    /**
     * f0 -> NoOpStmt() | ErrorStmt() | CJumpStmt() | JumpStmt() | HStoreStmt()
     * | HLoadStmt() | MoveStmt() | PrintStmt()
     */
    public R visit(Stmt n) {
        R _ret = null;
        n.f0.accept(this);
        return _ret;
    }

    /**
     * f0 -> "NOOP"
     */
    public R visit(NoOpStmt n) {
        R _ret = null;
        currnode = new CFNode();
        currnode.no = count;
        count++;
        if (label != null) {
            labelnodes.put(currfunc + label, currnode);
            label = null;
        }
        n.f0.accept(this);
        addNode();
        return _ret;
    }

    /**
     * f0 -> "ERROR"
     */
    public R visit(ErrorStmt n) {
        R _ret = null;
        currnode = new CFNode();
        currnode.no = count;
        count++;
        if (label != null) {
            labelnodes.put(currfunc + label, currnode);
            label = null;
        }
        n.f0.accept(this);
        addNode();
        return _ret;
    }

    /**
     * f0 -> "CJUMP" f1 -> Temp() f2 -> Label()
     */
    public R visit(CJumpStmt n) {
        R _ret = null;
        jumplabel = false;
        currnode = new CFNode();
        currnode.no = count;
        count++;
        if (label != null) {
            labelnodes.put(currfunc + label, currnode);
            label = null;
        }
        jumpnodes.put(currnode, currfunc + n.f2.f0.toString());
        n.f0.accept(this);
        currnode.use.add(currfunc + n.f1.accept(this));
        n.f2.accept(this);
        addNode();
        return _ret;
    }

    /**
     * f0 -> "JUMP" f1 -> Label()
     */
    public R visit(JumpStmt n) {
        R _ret = null;
        jumplabel = false;
        currnode = new CFNode();
        currnode.no = count;
        count++;
        if (label != null) {
            labelnodes.put(currfunc + label, currnode);
            label = null;
        }
        jumpnodes.put(currnode, currfunc + n.f1.f0.toString());
        n.f0.accept(this);
        n.f1.accept(this);
        addNode();
        prevnode = null; // jump statement makes the next statement headless.
        return _ret;
    }

    /**
     * f0 -> "HSTORE" f1 -> Temp() f2 -> IntegerLiteral() f3 -> Temp()
     */
    public R visit(HStoreStmt n) {
        R _ret = null;
        currnode = new CFNode();
        currnode.no = count;
        count++;
        if (label != null) {
            labelnodes.put(currfunc + label, currnode);
            label = null;
        }
        n.f0.accept(this);
        currnode.use.add(currfunc + n.f1.accept(this));
        n.f2.accept(this);
        currnode.use.add(currfunc + n.f3.accept(this));
        addNode();
        return _ret;
    }

    /**
     * f0 -> "HLOAD" f1 -> Temp() f2 -> Temp() f3 -> IntegerLiteral()
     */
    public R visit(HLoadStmt n) {
        R _ret = null;
        currnode = new CFNode();
        currnode.no = count;
        count++;
        if (label != null) {
            labelnodes.put(currfunc + label, currnode);
            label = null;
        }
        n.f0.accept(this);
        currnode.def.add(currfunc + n.f1.accept(this));
        currnode.use.add(currfunc + n.f2.accept(this));
        n.f3.accept(this);
        addNode();
        return _ret;
    }

    /**
     * f0 -> "MOVE" f1 -> Temp() f2 -> Exp()
     */
    public R visit(MoveStmt n) {
        R _ret = null;
        currnode = new CFNode();
        currnode.no = count;
        count++;
        if (label != null) {
            labelnodes.put(currfunc + label, currnode);
            label = null;
        }
        n.f0.accept(this);
        currnode.def.add(currfunc + n.f1.accept(this));
        String expval = (String) n.f2.accept(this);
        if (expval != null) {
            currnode.use.add(currfunc + expval);
        }
        addNode();
        return _ret;
    }

    /**
     * f0 -> "PRINT" f1 -> SimpleExp()
     */
    public R visit(PrintStmt n) {
        R _ret = null;
        currnode = new CFNode();
        currnode.no = count;
        count++;
        if (label != null) {
            labelnodes.put(currfunc + label, currnode);
            label = null;
        }
        n.f0.accept(this);
        String expval = (String) n.f1.accept(this);
        if (expval != null) {
            currnode.use.add(currfunc + expval);
        }
        addNode();
        return _ret;
    }

    /**
     * f0 -> Call() | HAllocate() | BinOp() | SimpleExp()
     */
    public R visit(Exp n) {
        R _ret = null;
        _ret = n.f0.accept(this);
        return _ret;
    }

    /**
     * f0 -> "BEGIN" f1 -> StmtList() f2 -> "RETURN" f3 -> SimpleExp() f4 ->
     * "END"
     */
    public R visit(StmtExp n) {
        R _ret = null;
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        currnode = new CFNode();
        currnode.no = count;
        count++;
        String expval = (String) n.f3.accept(this);
        if (expval != null) {
            currnode.use.add(currfunc + expval);
        }
        addNode();
        n.f4.accept(this);
        return _ret;
    }

    /**
     * f0 -> "CALL" f1 -> SimpleExp() f2 -> "(" f3 -> ( Temp() )* f4 -> ")"
     */
    public R visit(Call n) {
        R _ret = null;
        n.f0.accept(this);
        String expval = (String) n.f1.accept(this);
        if (expval != null) {
            currnode.use.add(currfunc + expval);
        }
        n.f2.accept(this);
        Integer curr_arg3 = symtab.arg3.get(currfunc);
        symtab.arg3.put(currfunc, Math.max(curr_arg3, n.f3.nodes.size()));
        for (Node node : n.f3.nodes) {
            currnode.use.add(currfunc + node.accept(this));
        }
        n.f4.accept(this);
        return _ret;
    }

    /**
     * f0 -> "HALLOCATE" f1 -> SimpleExp()
     */
    public R visit(HAllocate n) {
        R _ret = null;
        n.f0.accept(this);
        String expval = (String) n.f1.accept(this);
        if (expval != null) {
            currnode.use.add(currfunc + expval);
        }
        return _ret;
    }

    /**
     * f0 -> Operator() f1 -> Temp() f2 -> SimpleExp()
     */
    public R visit(BinOp n) {
        R _ret = null;
        n.f0.accept(this);
        currnode.use.add(currfunc + n.f1.accept(this));
        String expval = (String) n.f2.accept(this);
        if (expval != null) {
            currnode.use.add(currfunc + expval);
        }
        return _ret;
    }

    /**
     * f0 -> "LT" | "PLUS" | "MINUS" | "TIMES"
     */
    public R visit(Operator n) {
        R _ret = null;
        n.f0.accept(this);
        return _ret;
    }

    /**
     * f0 -> Temp() | IntegerLiteral() | Label()
     */
    public R visit(SimpleExp n) {
        R _ret = null;
        _ret = n.f0.accept(this);
        return _ret;
    }

    /**
     * f0 -> "TEMP" f1 -> IntegerLiteral()
     */
    public R visit(Temp n) {
        R _ret = null;
        n.f0.accept(this);
        n.f1.accept(this);
        return (R) n.f1.f0.toString();
    }

    /**
     * f0 -> <INTEGER_LITERAL>
     */
    public R visit(IntegerLiteral n) {
        R _ret = null;
        n.f0.accept(this);
        return _ret;
    }

    /**
     * f0 -> <IDENTIFIER>
     */
    public R visit(Label n) {
        R _ret = null;
        n.f0.accept(this);
        if (jumplabel) {
            label = n.f0.toString();
            symtab.global_label.put(currfunc + label, "L" + label_count++);
        }
        jumplabel = true;
        return _ret;
    }

}
