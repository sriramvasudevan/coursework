//
// Generated by JTB 1.3.2
//

package visitor;

import syntaxtree.*;
import java.util.*;

import base.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class typeCheckVisitor<R> implements GJNoArguVisitor<R> {

    public SymbolTable                  symtab; // No new SymbolTable() because
                                                 // it must be passed
                                                 // a symbol table.
    String                              classname, methname, called_classname,
            called_methname;
    ClassDef                            curr_class, called_curr_class;
    MethodDef                           curr_method, called_curr_method;
    Iterator<Map.Entry<String, String>> hash_it;
    int                                 param_nos;

    void printError(String error) {
        System.out.println(error);
        // System.out.println("Type error");
        System.exit(-1);
    }

    //
    // Auto class visitors--probably don't need to be overridden.
    //
    public R visit(NodeList n) {
        R _ret = null;
        int _count = 0;
        for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
            e.nextElement().accept(this);
            _count++;
        }
        return _ret;
    }

    public R visit(NodeListOptional n) {
        if (n.present()) {
            R _ret = null;
            int _count = 0;
            for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
                e.nextElement().accept(this);
                _count++;
            }
            return _ret;
        }
        else
            return null;
    }

    public R visit(NodeOptional n) {
        if (n.present())
            return n.node.accept(this);
        else
            return null;
    }

    public R visit(NodeSequence n) {
        R _ret = null;
        int _count = 0;
        for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
            e.nextElement().accept(this);
            _count++;
        }
        return _ret;
    }

    public R visit(NodeToken n) {
        return null;
    }

    //
    // User-generated visitor methods below
    //

    /**
     * f0 -> MainClass() f1 -> ( TypeDeclaration() )* f2 -> <EOF>
     */
    public R visit(Goal n) {
        R _ret = null;
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        return _ret;
    }

    /**
     * f0 -> "class" f1 -> Identifier() f2 -> "{" f3 -> "public" f4 -> "static"
     * f5 -> "void" f6 -> "main" f7 -> "(" f8 -> "String" f9 -> "[" f10 -> "]"
     * f11 -> Identifier() f12 -> ")" f13 -> "{" f14 -> PrintStatement() f15 ->
     * "}" f16 -> "}"
     */
    public R visit(MainClass n) {
        R _ret = null;
        classname = n.f1.f0.toString();
        if (!symtab.classes.containsKey(classname)) {
            printError("Non-existant class.");
        }
        curr_class = symtab.classes.get(classname);
        methname = n.f6.toString();
        if (!curr_class.methods.containsKey(methname)) {
            printError("Non-existant method.");
        }
        curr_method = curr_class.methods.get(methname);

        n.f14.accept(this);
        return _ret;
    }

    /**
     * f0 -> ClassDeclaration() | ClassExtendsDeclaration()
     */
    public R visit(TypeDeclaration n) {
        R _ret = null;
        n.f0.accept(this);
        return _ret;
    }

    /**
     * f0 -> "class" f1 -> Identifier() f2 -> "{" f3 -> ( VarDeclaration() )* f4
     * -> ( MethodDeclaration() )* f5 -> "}"
     */
    public R visit(ClassDeclaration n) {
        R _ret = null;
        classname = n.f1.f0.toString();
        if (!symtab.classes.containsKey(classname)) {
            printError("Non-existant class.");
        }
        curr_class = symtab.classes.get(classname);
        methname = null;
        n.f3.accept(this);
        n.f4.accept(this);
        return _ret;
    }

    /**
     * f0 -> "class" f1 -> Identifier() f2 -> "extends" f3 -> Identifier() f4 ->
     * "{" f5 -> ( VarDeclaration() )* f6 -> ( MethodDeclaration() )* f7 -> "}"
     */
    public R visit(ClassExtendsDeclaration n) {
        R _ret = null;
        classname = (String) n.f1.f0.toString();
        if (!symtab.classes.containsKey(classname)) {
            printError("Non-existant class.");
        }
        curr_class = symtab.classes.get(classname);
        methname = null;
        n.f5.accept(this);
        n.f6.accept(this);
        return _ret;
    }

    /**
     * f0 -> Type() f1 -> Identifier() f2 -> ";"
     */
    public R visit(VarDeclaration n) {
        R _ret = null;
        return _ret;
    }

    /**
     * f0 -> "public" f1 -> Type() f2 -> Identifier() f3 -> "(" f4 -> (
     * FormalParameterList() )? f5 -> ")" f6 -> "{" f7 -> ( VarDeclaration() )*
     * f8 -> ( Statement() )* f9 -> "return" f10 -> Expression() f11 -> ";" f12
     * -> "}"
     */
    public R visit(MethodDeclaration n) {
        R _ret = null;

        methname = n.f2.f0.toString();
        if (!curr_class.methods.containsKey(methname)) {
            printError("Non-existant method.");
        }
        curr_method = curr_class.methods.get(methname);

        n.f4.accept(this);
        n.f7.accept(this);
        n.f8.accept(this);
        String exp_ret_type = (String) n.f10.accept(this);
        if (!exp_ret_type.equals(curr_method.ret_type)) {
            // Check if it is a class
            if (!symtab.classes.containsKey(exp_ret_type)) {
                printError("return type doesn't match function definition."
                        + methname + classname);
            }
            // If it's a class
            ClassDef ret_class = symtab.classes.get(exp_ret_type);
            // If not a subtype of the return type
            if (!ret_class.extend.contains(curr_method.ret_type)) {
                printError("return type doesn't match function definition."
                        + methname + classname);
            }
        }
        return _ret;
    }

    /**
     * f0 -> FormalParameter() f1 -> ( FormalParameterRest() )*
     */
    public R visit(FormalParameterList n) {
        R _ret = null;
        n.f0.accept(this);
        n.f1.accept(this);
        return _ret;
    }

    /**
     * f0 -> Type() f1 -> Identifier()
     */
    public R visit(FormalParameter n) {
        R _ret = null;
        return _ret;
    }

    /**
     * f0 -> "," f1 -> FormalParameter()
     */
    public R visit(FormalParameterRest n) {
        R _ret = null;
        n.f1.accept(this);
        return _ret;
    }

    /**
     * f0 -> ArrayType() | BooleanType() | IntegerType() | Identifier()
     */
    public R visit(Type n) {
        R _ret = null;
        return n.f0.accept(this);
    }

    /**
     * f0 -> "int" f1 -> "[" f2 -> "]"
     */
    public R visit(ArrayType n) {
        R _ret = null;
        return (R) "int[]";
    }

    /**
     * f0 -> "boolean"
     */
    public R visit(BooleanType n) {
        R _ret = null;
        return (R) "boolean";
    }

    /**
     * f0 -> "int"
     */
    public R visit(IntegerType n) {
        R _ret = null;
        return (R) "int";
    }

    /**
     * f0 -> Block() | AssignmentStatement() | ArrayAssignmentStatement() |
     * IfStatement() | WhileStatement() | PrintStatement()
     */
    public R visit(Statement n) {
        R _ret = null;
        n.f0.accept(this);
        return _ret;
    }

    /**
     * f0 -> "{" f1 -> ( Statement() )* f2 -> "}"
     */
    public R visit(Block n) {
        R _ret = null;
        n.f1.accept(this);
        return _ret;
    }

    /**
     * f0 -> Identifier() f1 -> "=" f2 -> Expression() f3 -> ";"
     */
    public R visit(AssignmentStatement n) {
        R _ret = null;

        String identname = n.f0.f0.toString();
        String var_type = null;
        if (!curr_method.locals.containsKey(identname)) {
            if (!curr_method.params.containsKey(identname)) {
                if (!curr_class.vars.containsKey(identname)) {
                    printError(classname + " " + methname
                            + " class/method doesn't contain " + identname);
                }
                else {
                    var_type = curr_class.vars.get(identname);
                }
            }
            else {
                var_type = curr_method.params.get(identname);
            }
        }
        else {
            var_type = curr_method.locals.get(identname);
        }

        String exp_type = (String) n.f2.accept(this);
        if (!exp_type.equals(var_type)) {
            // Check if it is a class
            if (!symtab.classes.containsKey(exp_type)) {
                printError("Type mismatch in assignment");
            }
            // If it's a class
            ClassDef ret_class = symtab.classes.get(exp_type);
            // If not a subtype of the identifier type
            if (!ret_class.extend.contains(var_type)) {
                printError("Type mismatch in assignment");
            }
        }
        return _ret;
    }

    /**
     * f0 -> Identifier() f1 -> "[" f2 -> Expression() f3 -> "]" f4 -> "=" f5 ->
     * Expression() f6 -> ";"
     */
    public R visit(ArrayAssignmentStatement n) {
        R _ret = null;

        String identname = n.f0.f0.toString();
        String identtype = null;

        if (!curr_method.locals.containsKey(identname)) {
            if (!curr_method.params.containsKey(identname)) {
                if (!curr_class.vars.containsKey(identname)) {
                    printError(classname + " " + methname
                            + " class/method doesn't contain " + identname);
                }
                else {
                    identtype = curr_class.vars.get(identname);
                }
            }
            else {
                identtype = curr_method.params.get(identname);
            }
        }
        else {
            identtype = curr_method.locals.get(identname);
        }

        if (!n.f2.accept(this).equals("int")) {
            printError("Index must be int");
        }
        // Check if exp_type is int
        String exp_type = (String) n.f5.accept(this);
        if (!exp_type.equals("int")) {
            printError("Type mismatch in assignment");
        }

        return _ret;
    }

    /**
     * f0 -> "if" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement() f5 ->
     * "else" f6 -> Statement()
     */
    public R visit(IfStatement n) {
        R _ret = null;
        if (!n.f2.accept(this).equals("boolean")) {
            printError(n.f2.accept(this) + "it can take only boolean expr.");
        }
        n.f4.accept(this);
        n.f6.accept(this);
        return _ret;
    }

    /**
     * f0 -> "while" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement()
     */
    public R visit(WhileStatement n) {
        R _ret = null;
        if (!n.f2.accept(this).equals("boolean")) {
            printError("while can take only boolean expr.");
        }
        n.f4.accept(this);
        return _ret;
    }

    /**
     * f0 -> "System.out.println" f1 -> "(" f2 -> Expression() f3 -> ")" f4 ->
     * ";"
     */
    public R visit(PrintStatement n) {
        R _ret = null;
        if (!n.f2.accept(this).equals("int")) {
            printError("println can print only int");
        }
        return _ret;
    }

    /**
     * f0 -> AndExpression() | CompareExpression() | PlusExpression() |
     * MinusExpression() | TimesExpression() | ArrayLookup() | ArrayLength() |
     * MessageSend() | PrimaryExpression()
     */
    public R visit(Expression n) {
        R _ret = null;
        return n.f0.accept(this);
    }

    /**
     * f0 -> PrimaryExpression() f1 -> "&" f2 -> PrimaryExpression()
     */
    public R visit(AndExpression n) {
        R _ret = null;
        if ((!n.f0.accept(this).equals("boolean"))
                || (!n.f2.accept(this).equals("boolean"))) {
            printError("both terms of && must be boolean");
        }
        return (R) "boolean";
    }

/**
    * f0 -> PrimaryExpression()
    * f1 -> "<"
    * f2 -> PrimaryExpression()
    */
    public R visit(CompareExpression n) {
        R _ret = null;
        if ((!n.f0.accept(this).equals("int"))
                || (!n.f2.accept(this).equals("int"))) {
            printError("both terms of < must be int");
        }
        return (R) "boolean";
    }

    /**
     * f0 -> PrimaryExpression() f1 -> "+" f2 -> PrimaryExpression()
     */
    public R visit(PlusExpression n) {
        R _ret = null;
        if ((!n.f0.accept(this).equals("int"))
                || (!n.f2.accept(this).equals("int"))) {
            printError("both terms of + must be int");
        }
        return (R) "int";
    }

    /**
     * f0 -> PrimaryExpression() f1 -> "-" f2 -> PrimaryExpression()
     */
    public R visit(MinusExpression n) {
        R _ret = null;
        if ((!n.f0.accept(this).equals("int"))
                || (!n.f2.accept(this).equals("int"))) {
            printError("both terms of - must be int");
        }
        return (R) "int";
    }

    /**
     * f0 -> PrimaryExpression() f1 -> "*" f2 -> PrimaryExpression()
     */
    public R visit(TimesExpression n) {
        R _ret = null;
        if ((!n.f0.accept(this).equals("int"))
                || (!n.f2.accept(this).equals("int"))) {
            printError("both terms of * must be int");
        }
        return (R) "int";
    }

    /**
     * f0 -> PrimaryExpression() f1 -> "[" f2 -> PrimaryExpression() f3 -> "]"
     */
    public R visit(ArrayLookup n) {
        R _ret = null;
        String identtype = (String) n.f0.accept(this);
        if (!identtype.equals("int[]")) {
            printError("lookup can be called only on an array" + methname
                    + classname);
        }
        if (n.f0.f0.which == 3) { // 3 => Identifier, 5 => ArrayAllocation
            String identname = ((Identifier) n.f0.f0.choice).f0.toString();
            if (!curr_method.locals.containsKey(identname)
                    && !curr_method.params.containsKey(identname)
                    && !curr_class.vars.containsKey(identname)) {
                printError(identname
                        + " doesn't exist in the current method/class.");
            }
        }
        if (!n.f2.accept(this).equals("int")) {
            printError("Index must be int");
        }
        return (R) "int";
    }

    /**
     * f0 -> PrimaryExpression() f1 -> "." f2 -> "length"
     */
    public R visit(ArrayLength n) {
        R _ret = null;
        String identtype = (String) n.f0.accept(this);
        if (!identtype.equals("int[]")) {
            printError("length can be called only on an array");
        }

        if (n.f0.f0.which == 3) { // 3 => Identifier, 5 => ArrayAllocation
            String identname = ((Identifier) n.f0.f0.choice).f0.toString();
            if (!curr_method.locals.containsKey(identname)
                    && !curr_method.params.containsKey(identname)
                    && !curr_class.vars.containsKey(identname)) {
                printError(identname
                        + " doesn't exist in the current method/class.");
            }
        }
        return (R) "int";
    }

    /**
     * f0 -> PrimaryExpression() f1 -> "." f2 -> Identifier() f3 -> "(" f4 -> (
     * ExpressionList() )? f5 -> ")"
     */
    public R visit(MessageSend n) { 
        R _ret = null;
        called_classname = (String) n.f0.accept(this);
        String temp = called_classname;
        if (!symtab.classes.containsKey(called_classname)) {
            printError(called_classname + " class isn't present."
                    + n.f2.f0.toString());
        }

        if (n.f0.f0.which == 3) { // 3 => Identifier, 4 => ThisExpression, 6=>AllocationExpression
            String objname = ((Identifier) n.f0.f0.choice).f0.toString();
            if (!curr_method.locals.containsKey(objname)
                    && !curr_method.params.containsKey(objname)
                    && !curr_class.vars.containsKey(objname)) {
                printError(objname
                        + " doesn't exist in the current method/class.");
            }
        }
        
        called_curr_class = symtab.classes.get(called_classname);
        called_methname = n.f2.f0.toString();
        if (!called_curr_class.methods.containsKey(called_methname)) {
            printError(called_methname + " method isn't present in "
                    + called_classname);
        }
        called_curr_method = called_curr_class.methods.get(called_methname);
        param_nos = 0;

        n.f4.accept(this);

        // These values could have changed inside the f4 call. Reinitializing
        // them with these values.
        called_classname = temp;
        called_curr_class = symtab.classes.get(called_classname);
        called_methname = n.f2.f0.toString();
        called_curr_method = called_curr_class.methods.get(called_methname);

        if (called_curr_method.params.size() != param_nos) {
            printError("Unequal no. of parameters"+called_methname+called_curr_method.params.size()+" "+param_nos);
        }
        return (R) called_curr_method.ret_type;
    }

    /**
     * f0 -> Expression() f1 -> ( ExpressionRest() )*
     */
    public R visit(ExpressionList n) {
        R _ret = null;

        //backup values
        String temp_cc = called_classname;
        String temp_cm = called_methname;
        int temp_p = param_nos;
        
        hash_it = called_curr_method.params.entrySet().iterator();
        Iterator<Map.Entry<String, String>> temp_hash = hash_it; //backup
        
        Map.Entry<String, String> entry = hash_it.next();
        
        String exp_type = (String) n.f0.accept(this);
        if (!entry.getValue().equals(exp_type)) {
            // Check if it is a class
            if (!symtab.classes.containsKey(exp_type)) {
                printError(called_methname + called_classname
                        + "Actuals type don't match formals type." + methname
                        + classname);
            }
            // If it's a class
            ClassDef ret_class = symtab.classes.get(exp_type);
            // If not a subtype of the identifier type
            if (!ret_class.extend.contains(entry.getValue())) {
                printError(called_methname + called_classname
                        + "Actuals type don't match formals type." + methname
                        + classname);
            }
        }
        
        //Restore values
        called_classname = temp_cc;
        called_curr_class = symtab.classes.get(called_classname);
        called_methname = temp_cm;
        called_curr_method = called_curr_class.methods.get(called_methname);
        param_nos = temp_p;
        hash_it = temp_hash;
        
        param_nos++;
        n.f1.accept(this);
        return _ret;
    }

    /**
     * f0 -> "," f1 -> Expression()
     */
    public R visit(ExpressionRest n) {
        R _ret = null;
        
        //backup values
        String temp_cc = called_classname;
        String temp_cm = called_methname;
        int temp_p = param_nos;
        Iterator<Map.Entry<String, String>> temp_hash = hash_it; //backup
        
        Map.Entry<String, String> entry = hash_it.next();
        
        String exp_type = (String) n.f1.accept(this);
        if (!entry.getValue().equals(exp_type)) {
            // Check if it is a class
            if (!symtab.classes.containsKey(exp_type)) {
                printError(called_methname + called_classname
                        + "Actuals type don't match formals type." + methname
                        + classname);
            }
            // If it's a class
            ClassDef ret_class = symtab.classes.get(exp_type);
            // If not a subtype of the identifier type
            if (!ret_class.extend.contains(entry.getValue())) {
                printError(called_methname + called_classname
                        + "Actuals type don't match formals type." + methname
                        + classname);
            }
        }
        
        //Restore values
        called_classname = temp_cc;
        called_curr_class = symtab.classes.get(called_classname);
        called_methname = temp_cm;
        called_curr_method = called_curr_class.methods.get(called_methname);
        param_nos = temp_p;
        hash_it = temp_hash;
        
        param_nos++;
        return _ret;
    }

    /**
     * f0 -> IntegerLiteral() | TrueLiteral() | FalseLiteral() | Identifier() |
     * ThisExpression() | ArrayAllocationExpression() | AllocationExpression() |
     * NotExpression() | BracketExpression()
     */
    public R visit(PrimaryExpression n) {
        R _ret = null;
        return n.f0.accept(this);
    }

    /**
     * f0 -> <INTEGER_LITERAL>
     */
    public R visit(IntegerLiteral n) {
        R _ret = null;
        return (R) "int";
    }

    /**
     * f0 -> "true"
     */
    public R visit(TrueLiteral n) {
        R _ret = null;
        return (R) "boolean";
    }

    /**
     * f0 -> "false"
     */
    public R visit(FalseLiteral n) {
        R _ret = null;
        return (R) "boolean";
    }

    /**
     * f0 -> <IDENTIFIER>
     */
    public R visit(Identifier n) {
        R _ret = null;
        if (curr_method.locals.containsKey(n.f0.toString())) {
            return (R) curr_method.locals.get(n.f0.toString());
        }
        else if (curr_method.params.containsKey(n.f0.toString())) {
            return (R) curr_method.params.get(n.f0.toString());
        }
        else if (curr_class.vars.containsKey(n.f0.toString())) {
            return (R) curr_class.vars.get(n.f0.toString());
        }
        else if (symtab.classes.containsKey(n.f0.toString())) {
            return (R) n.f0.toString(); // It's a class name
        }
        else {
            printError("Identifier doesn't exist!");
        }
        return _ret;
    }

    /**
     * f0 -> "this"
     */
    public R visit(ThisExpression n) {
        R _ret = null;
        return (R) classname;
    }

    /**
     * f0 -> "new" f1 -> "int" f2 -> "[" f3 -> Expression() f4 -> "]"
     */
    public R visit(ArrayAllocationExpression n) {
        R _ret = null;
        if (!n.f3.accept(this).equals("int")) {
            printError("Index must be int");
        }
        return (R) "int[]";
    }

    /**
     * f0 -> "new" f1 -> Identifier() f2 -> "(" f3 -> ")"
     */
    public R visit(AllocationExpression n) {
        R _ret = null;
        return n.f1.accept(this);
    }

    /**
     * f0 -> "!" f1 -> Expression()
     */
    public R visit(NotExpression n) {
        R _ret = null;
        if (!n.f1.accept(this).equals("boolean")) {
            printError("You can ! only a boolean expression");
        }
        return (R) "boolean";
    }

    /**
     * f0 -> "(" f1 -> Expression() f2 -> ")"
     */
    public R visit(BracketExpression n) {
        R _ret = null;
        return n.f1.accept(this);
    }

}
